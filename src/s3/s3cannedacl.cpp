// S3CannedACL.cpp
// By Mike Kuta
// Thursday, August 27, 2015
//
// Canned ACLs for Amazon S3 (preset permissions).
//
// Extension of libqtaws.  libqtaws is licensed under the GNU Lesser General Public License.
//
// https://github.com/pcolby/libqtaws
//
// Copyright Â© 2015 Kuta Software LLC.  All rights reserved.


#include "s3cannedacl.h"
#include "s3cannedacl_p.h"

#include <QDebug>


#define CANNED_ACL_PRIVATE                  QLatin1String("private")
#define CANNED_ACL_PUBLIC_READ              QLatin1String("public-read")
#define CANNED_ACL_PUBLIC_READ_WRITE        QLatin1String("public-read-write")
#define CANNED_ACL_AUTHENTICATED_READ       QLatin1String("authenticated-read")
#define CANNED_ACL_BUCKET_OWNER_READ        QLatin1String("bucket-owner-read")
#define CANNED_ACL_BUCKET_OWNER_FULL_CONTOL QLatin1String("bucket-owner-full-control")
#define CANNED_ACL_LOG_DELIVERY_WRITE       QLatin1String("log-delivery-write")


QTAWS_BEGIN_NAMESPACE



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
S3CannedACL::S3CannedACL(const S3CannedACL::Value & cannedACL)
    : d_ptr(new S3CannedACLPrivate(cannedACL, this))
{

}




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
S3CannedACL::S3CannedACL(const S3CannedACL & other)
    : d_ptr(new S3CannedACLPrivate(*other.d_ptr, this))
{

}




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
S3CannedACL::~S3CannedACL()
{
    delete d_ptr;
}




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
S3CannedACL & S3CannedACL::operator=(const S3CannedACL & other)
{
    d_ptr->cannedACL = other.d_ptr->cannedACL;
    return *this;
}




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
QString S3CannedACL::toString() const
{
    switch (d_ptr->cannedACL)
    {
    case Private:                 return CANNED_ACL_PRIVATE;
    case PublicRead:              return CANNED_ACL_PUBLIC_READ;
    case PublicReadWrite:         return CANNED_ACL_PUBLIC_READ_WRITE;
    case AuthenticatedRead:       return CANNED_ACL_AUTHENTICATED_READ;
    case BucketOwnerRead:         return CANNED_ACL_BUCKET_OWNER_READ;
    case BucketOwnerFullControl:  return CANNED_ACL_BUCKET_OWNER_FULL_CONTOL;
    case LogDeliveryWrite:        return CANNED_ACL_LOG_DELIVERY_WRITE;
    default:
        Q_ASSERT_X(false, Q_FUNC_INFO, qPrintable(QString::fromLatin1("Invalid canned ACL: %1").arg(d_ptr->cannedACL)));
    }
    return QString();
}




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
S3CannedACL S3CannedACL::fromString(const QString & cannedACL)
{
    if (cannedACL.compare(CANNED_ACL_PRIVATE,                   Qt::CaseInsensitive)) return S3CannedACL::Private;
    if (cannedACL.compare(CANNED_ACL_PUBLIC_READ,               Qt::CaseInsensitive)) return S3CannedACL::PublicRead;
    if (cannedACL.compare(CANNED_ACL_PUBLIC_READ_WRITE,         Qt::CaseInsensitive)) return S3CannedACL::PublicReadWrite;
    if (cannedACL.compare(CANNED_ACL_AUTHENTICATED_READ,        Qt::CaseInsensitive)) return S3CannedACL::AuthenticatedRead;
    if (cannedACL.compare(CANNED_ACL_BUCKET_OWNER_READ,         Qt::CaseInsensitive)) return S3CannedACL::BucketOwnerRead;
    if (cannedACL.compare(CANNED_ACL_BUCKET_OWNER_FULL_CONTOL,  Qt::CaseInsensitive)) return S3CannedACL::BucketOwnerFullControl;
    if (cannedACL.compare(CANNED_ACL_LOG_DELIVERY_WRITE,        Qt::CaseInsensitive)) return S3CannedACL::LogDeliveryWrite;
    qWarning() << "Unknown canned ACL value" << cannedACL;
    return S3CannedACL::Other;
}




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool S3CannedACL::isDefault() const
{
    return (d_ptr->cannedACL == Private);
}




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool S3CannedACL::isValidForObjects() const
{
    return ((d_ptr->cannedACL == Private)           ||
            (d_ptr->cannedACL == PublicRead)        ||
            (d_ptr->cannedACL == PublicReadWrite)   ||
            (d_ptr->cannedACL == AuthenticatedRead) ||
            (d_ptr->cannedACL == BucketOwnerRead)   ||
            (d_ptr->cannedACL == BucketOwnerFullControl));
}




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool S3CannedACL::isValidForBuckets() const
{
    return ((d_ptr->cannedACL == Private)           ||
            (d_ptr->cannedACL == PublicRead)        ||
            (d_ptr->cannedACL == PublicReadWrite)   ||
            (d_ptr->cannedACL == AuthenticatedRead) ||
            (d_ptr->cannedACL == LogDeliveryWrite));
}




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool S3CannedACL::operator==(const S3CannedACL & other) const
{
    return (d_ptr->cannedACL == other.d_ptr->cannedACL);
}




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
S3CannedACLPrivate::S3CannedACLPrivate(const int cannedACL, S3CannedACL * const q)
    : cannedACL(cannedACL)
    , q_ptr(q)
{

}




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
S3CannedACLPrivate::S3CannedACLPrivate(const S3CannedACLPrivate & other, S3CannedACL * const q)
    : cannedACL(other.cannedACL)
    , q_ptr(q)
{

}


QTAWS_END_NAMESPACE
